import{r as f,u as K,ax as Xe,i as Fe,_ as We,a2 as Ve,c as N,ab as me,aa as pe,ay as $e,az as Te,aA as Ke,ag as ze,aB as He,J as W,aC as re,aD as ce,j as Re}from"./index-2390be2e.js";const be=new N,Ie=new N,Be=new N;function Ge(o,a,i){const e=be.setFromMatrixPosition(o.matrixWorld);e.project(a);const P=i.width/2,E=i.height/2;return[e.x*P+P,-(e.y*E)+E]}function qe(o,a){const i=be.setFromMatrixPosition(o.matrixWorld),e=Ie.setFromMatrixPosition(a.matrixWorld),P=i.sub(e),E=a.getWorldDirection(Be);return P.angleTo(E)>Math.PI/2}function Qe(o,a,i,e){const P=be.setFromMatrixPosition(o.matrixWorld),E=P.clone();E.project(a),i.setFromCamera(E,a);const x=i.intersectObjects(e,!0);if(x.length){const c=x[0].distance;return P.distanceTo(i.ray.origin)<c}return!0}function Je(o,a){if(a instanceof me)return a.zoom;if(a instanceof pe){const i=be.setFromMatrixPosition(o.matrixWorld),e=Ie.setFromMatrixPosition(a.matrixWorld),P=a.fov*Math.PI/180,E=i.distanceTo(e);return 1/(2*Math.tan(P/2)*E)}else return 1}function et(o,a,i){if(a instanceof pe||a instanceof me){const e=be.setFromMatrixPosition(o.matrixWorld),P=Ie.setFromMatrixPosition(a.matrixWorld),E=e.distanceTo(P),x=(i[1]-i[0])/(a.far-a.near),c=i[1]-x*a.far;return Math.round(x*E+c)}}const Ne=o=>Math.abs(o)<1e-10?0:o;function Ze(o,a,i=""){let e="matrix3d(";for(let P=0;P!==16;P++)e+=Ne(a[P]*o.elements[P])+(P!==15?",":")");return i+e}const tt=(o=>a=>Ze(a,o))([1,-1,1,1,1,-1,1,1,1,-1,1,1,1,-1,1,1]),nt=(o=>(a,i)=>Ze(a,o(i),"translate(-50%,-50%)"))(o=>[1/o,1/o,1/o,1,-1/o,-1/o,-1/o,-1,1/o,1/o,1/o,1,1,1,1,1]);function ot(o){return o&&typeof o=="object"&&"current"in o}const at=f.forwardRef(({children:o,eps:a=.001,style:i,className:e,prepend:P,center:E,fullscreen:x,portal:c,distanceFactor:h,sprite:te=!1,transform:u=!1,occlude:m,onOcclude:Z,castShadow:_,receiveShadow:B,material:I,geometry:j,zIndexRange:D=[16777271,0],calculatePosition:L=Ge,as:S="div",wrapperClass:A,pointerEvents:g="auto",...l},C)=>{const{gl:d,camera:y,scene:ge,size:v,raycaster:le,events:ye,viewport:Pe}=K(),[M]=f.useState(()=>document.createElement(S)),k=f.useRef(),O=f.useRef(null),ue=f.useRef(0),Q=f.useRef([0,0]),J=f.useRef(null),ne=f.useRef(null),G=(c==null?void 0:c.current)||ye.connected||d.domElement.parentNode,z=f.useRef(null),oe=f.useRef(!1),ae=f.useMemo(()=>m&&m!=="blending"||Array.isArray(m)&&m.length&&ot(m[0]),[m]);f.useLayoutEffect(()=>{const w=d.domElement;m&&m==="blending"?(w.style.zIndex=`${Math.floor(D[0]/2)}`,w.style.position="absolute",w.style.pointerEvents="none"):(w.style.zIndex=null,w.style.position=null,w.style.pointerEvents=null)},[m]),f.useLayoutEffect(()=>{if(O.current){const w=k.current=Xe(M);if(ge.updateMatrixWorld(),u)M.style.cssText="position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";else{const b=L(O.current,y,v);M.style.cssText=`position:absolute;top:0;left:0;transform:translate3d(${b[0]}px,${b[1]}px,0);transform-origin:0 0;`}return G&&(P?G.prepend(M):G.appendChild(M)),()=>{G&&G.removeChild(M),w.unmount()}}},[G,u]),f.useLayoutEffect(()=>{A&&(M.className=A)},[A]);const Ee=f.useMemo(()=>u?{position:"absolute",top:0,left:0,width:v.width,height:v.height,transformStyle:"preserve-3d",pointerEvents:"none"}:{position:"absolute",transform:E?"translate3d(-50%,-50%,0)":"none",...x&&{top:-v.height/2,left:-v.width/2,width:v.width,height:v.height},...i},[i,E,x,v,u]),ve=f.useMemo(()=>({position:"absolute",pointerEvents:g}),[g]);f.useLayoutEffect(()=>{if(oe.current=!1,u){var w;(w=k.current)==null||w.render(f.createElement("div",{ref:J,style:Ee},f.createElement("div",{ref:ne,style:ve},f.createElement("div",{ref:C,className:e,style:i,children:o}))))}else{var b;(b=k.current)==null||b.render(f.createElement("div",{ref:C,style:Ee,className:e,children:o}))}});const U=f.useRef(!0);Fe(w=>{if(O.current){y.updateMatrixWorld(),O.current.updateWorldMatrix(!0,!1);const b=u?Q.current:L(O.current,y,v);if(u||Math.abs(ue.current-y.zoom)>a||Math.abs(Q.current[0]-b[0])>a||Math.abs(Q.current[1]-b[1])>a){const H=qe(O.current,y);let R=!1;ae&&(m!=="blending"?R=[ge]:Array.isArray(m)&&(R=m.map(Y=>Y.current)));const q=U.current;if(R){const Y=Qe(O.current,y,le,R);U.current=Y&&!H}else U.current=!H;q!==U.current&&(Z?Z(!U.current):M.style.display=U.current?"block":"none");const ie=Math.floor(D[0]/2),we=m?ae?[D[0],ie]:[ie-1,0]:D;if(M.style.zIndex=`${et(O.current,y,we)}`,u){const[Y,se]=[v.width/2,v.height/2],ee=y.projectionMatrix.elements[5]*se,{isOrthographicCamera:he,top:Ae,left:je,bottom:Me,right:xe}=y,De=tt(y.matrixWorldInverse),Le=he?`scale(${ee})translate(${Ne(-(xe+je)/2)}px,${Ne((Ae+Me)/2)}px)`:`translateZ(${ee}px)`;let F=O.current.matrixWorld;te&&(F=y.matrixWorldInverse.clone().transpose().copyPosition(F).scale(O.current.scale),F.elements[3]=F.elements[7]=F.elements[11]=0,F.elements[15]=1),M.style.width=v.width+"px",M.style.height=v.height+"px",M.style.perspective=he?"":`${ee}px`,J.current&&ne.current&&(J.current.style.transform=`${Le}${De}translate(${Y}px,${se}px)`,ne.current.style.transform=nt(F,1/((h||10)/400)))}else{const Y=h===void 0?1:Je(O.current,y)*h;M.style.transform=`translate3d(${b[0]}px,${b[1]}px,0) scale(${Y})`}Q.current=b,ue.current=y.zoom}}if(!ae&&z.current&&!oe.current)if(u){if(J.current){const b=J.current.children[0];if(b!=null&&b.clientWidth&&b!=null&&b.clientHeight){const{isOrthographicCamera:H}=y;if(H||j)l.scale&&(Array.isArray(l.scale)?l.scale instanceof N?z.current.scale.copy(l.scale.clone().divideScalar(1)):z.current.scale.set(1/l.scale[0],1/l.scale[1],1/l.scale[2]):z.current.scale.setScalar(1/l.scale));else{const R=(h||10)/400,q=b.clientWidth*R,ie=b.clientHeight*R;z.current.scale.set(q,ie,1)}oe.current=!0}}}else{const b=M.children[0];if(b!=null&&b.clientWidth&&b!=null&&b.clientHeight){const H=1/Pe.factor,R=b.clientWidth*H,q=b.clientHeight*H;z.current.scale.set(R,q,1),oe.current=!0}z.current.lookAt(w.camera.position)}});const de=f.useMemo(()=>({vertexShader:u?void 0:`
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom" 
            is false. 
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;
            
            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,fragmentShader:`
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `}),[u]);return f.createElement("group",We({},l,{ref:O}),m&&!ae&&f.createElement("mesh",{castShadow:_,receiveShadow:B,ref:z},j||f.createElement("planeGeometry",null),I||f.createElement("shaderMaterial",{side:Ve,vertexShader:de.vertexShader,fragmentShader:de.fragmentShader})))});let fe=0;const it=$e(o=>(Te.onStart=(a,i,e)=>{o({active:!0,item:a,loaded:i,total:e,progress:(i-fe)/(e-fe)*100})},Te.onLoad=()=>{o({active:!1})},Te.onError=a=>o(i=>({errors:[...i.errors,a]})),Te.onProgress=(a,i,e)=>{i===e&&(fe=e),o({active:!0,item:a,loaded:i,total:e,progress:(i-fe)/(e-fe)*100||100})},{errors:[],active:!1,progress:0,item:"",loaded:0,total:0}));var st=Object.defineProperty,rt=(o,a,i)=>a in o?st(o,a,{enumerable:!0,configurable:!0,writable:!0,value:i}):o[a]=i,s=(o,a,i)=>(rt(o,typeof a!="symbol"?a+"":a,i),i);const Ye=(o,a)=>(o%a+a)%a;let ct=class extends Ke{constructor(a,i){super(),s(this,"object"),s(this,"domElement"),s(this,"enabled",!0),s(this,"target",new N),s(this,"minDistance",0),s(this,"maxDistance",1/0),s(this,"minZoom",0),s(this,"maxZoom",1/0),s(this,"minPolarAngle",0),s(this,"maxPolarAngle",Math.PI),s(this,"minAzimuthAngle",-1/0),s(this,"maxAzimuthAngle",1/0),s(this,"enableDamping",!1),s(this,"dampingFactor",.05),s(this,"enableZoom",!0),s(this,"zoomSpeed",1),s(this,"enableRotate",!0),s(this,"rotateSpeed",1),s(this,"enablePan",!0),s(this,"panSpeed",1),s(this,"screenSpacePanning",!0),s(this,"keyPanSpeed",7),s(this,"autoRotate",!1),s(this,"autoRotateSpeed",2),s(this,"reverseOrbit",!1),s(this,"keys",{LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"}),s(this,"mouseButtons",{LEFT:re.ROTATE,MIDDLE:re.DOLLY,RIGHT:re.PAN}),s(this,"touches",{ONE:ce.ROTATE,TWO:ce.DOLLY_PAN}),s(this,"target0"),s(this,"position0"),s(this,"zoom0"),s(this,"_domElementKeyEvents",null),s(this,"getPolarAngle"),s(this,"getAzimuthalAngle"),s(this,"setPolarAngle"),s(this,"setAzimuthalAngle"),s(this,"getDistance"),s(this,"listenToKeyEvents"),s(this,"saveState"),s(this,"reset"),s(this,"update"),s(this,"connect"),s(this,"dispose"),this.object=a,this.domElement=i,this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=()=>u.phi,this.getAzimuthalAngle=()=>u.theta,this.setPolarAngle=t=>{let n=Ye(t,2*Math.PI),r=u.phi;r<0&&(r+=2*Math.PI),n<0&&(n+=2*Math.PI);let p=Math.abs(n-r);2*Math.PI-p<p&&(n<r?n+=2*Math.PI:r+=2*Math.PI),m.phi=n-r,e.update()},this.setAzimuthalAngle=t=>{let n=Ye(t,2*Math.PI),r=u.theta;r<0&&(r+=2*Math.PI),n<0&&(n+=2*Math.PI);let p=Math.abs(n-r);2*Math.PI-p<p&&(n<r?n+=2*Math.PI:r+=2*Math.PI),m.theta=n-r,e.update()},this.getDistance=()=>e.object.position.distanceTo(e.target),this.listenToKeyEvents=t=>{t.addEventListener("keydown",xe),this._domElementKeyEvents=t},this.saveState=()=>{e.target0.copy(e.target),e.position0.copy(e.object.position),e.zoom0=e.object.zoom},this.reset=()=>{e.target.copy(e.target0),e.object.position.copy(e.position0),e.object.zoom=e.zoom0,e.object.updateProjectionMatrix(),e.dispatchEvent(P),e.update(),h=c.NONE},this.update=(()=>{const t=new N,n=new ze().setFromUnitVectors(a.up,new N(0,1,0)),r=n.clone().invert(),p=new N,T=new ze,X=2*Math.PI;return function(){const ke=e.object.position;t.copy(ke).sub(e.target),t.applyQuaternion(n),u.setFromVector3(t),e.autoRotate&&h===c.NONE&&le(ge()),e.enableDamping?(u.theta+=m.theta*e.dampingFactor,u.phi+=m.phi*e.dampingFactor):(u.theta+=m.theta,u.phi+=m.phi);let V=e.minAzimuthAngle,$=e.maxAzimuthAngle;return isFinite(V)&&isFinite($)&&(V<-Math.PI?V+=X:V>Math.PI&&(V-=X),$<-Math.PI?$+=X:$>Math.PI&&($-=X),V<=$?u.theta=Math.max(V,Math.min($,u.theta)):u.theta=u.theta>(V+$)/2?Math.max(V,u.theta):Math.min($,u.theta)),u.phi=Math.max(e.minPolarAngle,Math.min(e.maxPolarAngle,u.phi)),u.makeSafe(),u.radius*=Z,u.radius=Math.max(e.minDistance,Math.min(e.maxDistance,u.radius)),e.enableDamping===!0?e.target.addScaledVector(_,e.dampingFactor):e.target.add(_),t.setFromSpherical(u),t.applyQuaternion(r),ke.copy(e.target).add(t),e.object.lookAt(e.target),e.enableDamping===!0?(m.theta*=1-e.dampingFactor,m.phi*=1-e.dampingFactor,_.multiplyScalar(1-e.dampingFactor)):(m.set(0,0,0),_.set(0,0,0)),Z=1,B||p.distanceToSquared(e.object.position)>te||8*(1-T.dot(e.object.quaternion))>te?(e.dispatchEvent(P),p.copy(e.object.position),T.copy(e.object.quaternion),B=!1,!0):!1}})(),this.connect=t=>{t===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),e.domElement=t,e.domElement.style.touchAction="none",e.domElement.addEventListener("contextmenu",F),e.domElement.addEventListener("pointerdown",Y),e.domElement.addEventListener("pointercancel",he),e.domElement.addEventListener("wheel",Me)},this.dispose=()=>{var t,n,r,p,T,X;(t=e.domElement)==null||t.removeEventListener("contextmenu",F),(n=e.domElement)==null||n.removeEventListener("pointerdown",Y),(r=e.domElement)==null||r.removeEventListener("pointercancel",he),(p=e.domElement)==null||p.removeEventListener("wheel",Me),(T=e.domElement)==null||T.ownerDocument.removeEventListener("pointermove",se),(X=e.domElement)==null||X.ownerDocument.removeEventListener("pointerup",ee),e._domElementKeyEvents!==null&&e._domElementKeyEvents.removeEventListener("keydown",xe)};const e=this,P={type:"change"},E={type:"start"},x={type:"end"},c={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let h=c.NONE;const te=1e-6,u=new He,m=new He;let Z=1;const _=new N;let B=!1;const I=new W,j=new W,D=new W,L=new W,S=new W,A=new W,g=new W,l=new W,C=new W,d=[],y={};function ge(){return 2*Math.PI/60/60*e.autoRotateSpeed}function v(){return Math.pow(.95,e.zoomSpeed)}function le(t){e.reverseOrbit?m.theta+=t:m.theta-=t}function ye(t){e.reverseOrbit?m.phi+=t:m.phi-=t}const Pe=(()=>{const t=new N;return function(r,p){t.setFromMatrixColumn(p,0),t.multiplyScalar(-r),_.add(t)}})(),M=(()=>{const t=new N;return function(r,p){e.screenSpacePanning===!0?t.setFromMatrixColumn(p,1):(t.setFromMatrixColumn(p,0),t.crossVectors(e.object.up,t)),t.multiplyScalar(r),_.add(t)}})(),k=(()=>{const t=new N;return function(r,p){const T=e.domElement;if(T&&e.object instanceof pe&&e.object.isPerspectiveCamera){const X=e.object.position;t.copy(X).sub(e.target);let Oe=t.length();Oe*=Math.tan(e.object.fov/2*Math.PI/180),Pe(2*r*Oe/T.clientHeight,e.object.matrix),M(2*p*Oe/T.clientHeight,e.object.matrix)}else T&&e.object instanceof me&&e.object.isOrthographicCamera?(Pe(r*(e.object.right-e.object.left)/e.object.zoom/T.clientWidth,e.object.matrix),M(p*(e.object.top-e.object.bottom)/e.object.zoom/T.clientHeight,e.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),e.enablePan=!1)}})();function O(t){e.object instanceof pe&&e.object.isPerspectiveCamera?Z/=t:e.object instanceof me&&e.object.isOrthographicCamera?(e.object.zoom=Math.max(e.minZoom,Math.min(e.maxZoom,e.object.zoom*t)),e.object.updateProjectionMatrix(),B=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),e.enableZoom=!1)}function ue(t){e.object instanceof pe&&e.object.isPerspectiveCamera?Z*=t:e.object instanceof me&&e.object.isOrthographicCamera?(e.object.zoom=Math.max(e.minZoom,Math.min(e.maxZoom,e.object.zoom/t)),e.object.updateProjectionMatrix(),B=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),e.enableZoom=!1)}function Q(t){I.set(t.clientX,t.clientY)}function J(t){g.set(t.clientX,t.clientY)}function ne(t){L.set(t.clientX,t.clientY)}function G(t){j.set(t.clientX,t.clientY),D.subVectors(j,I).multiplyScalar(e.rotateSpeed);const n=e.domElement;n&&(le(2*Math.PI*D.x/n.clientHeight),ye(2*Math.PI*D.y/n.clientHeight)),I.copy(j),e.update()}function z(t){l.set(t.clientX,t.clientY),C.subVectors(l,g),C.y>0?O(v()):C.y<0&&ue(v()),g.copy(l),e.update()}function oe(t){S.set(t.clientX,t.clientY),A.subVectors(S,L).multiplyScalar(e.panSpeed),k(A.x,A.y),L.copy(S),e.update()}function ae(t){t.deltaY<0?ue(v()):t.deltaY>0&&O(v()),e.update()}function Ee(t){let n=!1;switch(t.code){case e.keys.UP:k(0,e.keyPanSpeed),n=!0;break;case e.keys.BOTTOM:k(0,-e.keyPanSpeed),n=!0;break;case e.keys.LEFT:k(e.keyPanSpeed,0),n=!0;break;case e.keys.RIGHT:k(-e.keyPanSpeed,0),n=!0;break}n&&(t.preventDefault(),e.update())}function ve(){if(d.length==1)I.set(d[0].pageX,d[0].pageY);else{const t=.5*(d[0].pageX+d[1].pageX),n=.5*(d[0].pageY+d[1].pageY);I.set(t,n)}}function U(){if(d.length==1)L.set(d[0].pageX,d[0].pageY);else{const t=.5*(d[0].pageX+d[1].pageX),n=.5*(d[0].pageY+d[1].pageY);L.set(t,n)}}function de(){const t=d[0].pageX-d[1].pageX,n=d[0].pageY-d[1].pageY,r=Math.sqrt(t*t+n*n);g.set(0,r)}function w(){e.enableZoom&&de(),e.enablePan&&U()}function b(){e.enableZoom&&de(),e.enableRotate&&ve()}function H(t){if(d.length==1)j.set(t.pageX,t.pageY);else{const r=Se(t),p=.5*(t.pageX+r.x),T=.5*(t.pageY+r.y);j.set(p,T)}D.subVectors(j,I).multiplyScalar(e.rotateSpeed);const n=e.domElement;n&&(le(2*Math.PI*D.x/n.clientHeight),ye(2*Math.PI*D.y/n.clientHeight)),I.copy(j)}function R(t){if(d.length==1)S.set(t.pageX,t.pageY);else{const n=Se(t),r=.5*(t.pageX+n.x),p=.5*(t.pageY+n.y);S.set(r,p)}A.subVectors(S,L).multiplyScalar(e.panSpeed),k(A.x,A.y),L.copy(S)}function q(t){const n=Se(t),r=t.pageX-n.x,p=t.pageY-n.y,T=Math.sqrt(r*r+p*p);l.set(0,T),C.set(0,Math.pow(l.y/g.y,e.zoomSpeed)),O(C.y),g.copy(l)}function ie(t){e.enableZoom&&q(t),e.enablePan&&R(t)}function we(t){e.enableZoom&&q(t),e.enableRotate&&H(t)}function Y(t){var n,r;e.enabled!==!1&&(d.length===0&&((n=e.domElement)==null||n.ownerDocument.addEventListener("pointermove",se),(r=e.domElement)==null||r.ownerDocument.addEventListener("pointerup",ee)),Ue(t),t.pointerType==="touch"?De(t):Ae(t))}function se(t){e.enabled!==!1&&(t.pointerType==="touch"?Le(t):je(t))}function ee(t){var n,r,p;Ce(t),d.length===0&&((n=e.domElement)==null||n.releasePointerCapture(t.pointerId),(r=e.domElement)==null||r.ownerDocument.removeEventListener("pointermove",se),(p=e.domElement)==null||p.ownerDocument.removeEventListener("pointerup",ee)),e.dispatchEvent(x),h=c.NONE}function he(t){Ce(t)}function Ae(t){let n;switch(t.button){case 0:n=e.mouseButtons.LEFT;break;case 1:n=e.mouseButtons.MIDDLE;break;case 2:n=e.mouseButtons.RIGHT;break;default:n=-1}switch(n){case re.DOLLY:if(e.enableZoom===!1)return;J(t),h=c.DOLLY;break;case re.ROTATE:if(t.ctrlKey||t.metaKey||t.shiftKey){if(e.enablePan===!1)return;ne(t),h=c.PAN}else{if(e.enableRotate===!1)return;Q(t),h=c.ROTATE}break;case re.PAN:if(t.ctrlKey||t.metaKey||t.shiftKey){if(e.enableRotate===!1)return;Q(t),h=c.ROTATE}else{if(e.enablePan===!1)return;ne(t),h=c.PAN}break;default:h=c.NONE}h!==c.NONE&&e.dispatchEvent(E)}function je(t){if(e.enabled!==!1)switch(h){case c.ROTATE:if(e.enableRotate===!1)return;G(t);break;case c.DOLLY:if(e.enableZoom===!1)return;z(t);break;case c.PAN:if(e.enablePan===!1)return;oe(t);break}}function Me(t){e.enabled===!1||e.enableZoom===!1||h!==c.NONE&&h!==c.ROTATE||(t.preventDefault(),e.dispatchEvent(E),ae(t),e.dispatchEvent(x))}function xe(t){e.enabled===!1||e.enablePan===!1||Ee(t)}function De(t){switch(_e(t),d.length){case 1:switch(e.touches.ONE){case ce.ROTATE:if(e.enableRotate===!1)return;ve(),h=c.TOUCH_ROTATE;break;case ce.PAN:if(e.enablePan===!1)return;U(),h=c.TOUCH_PAN;break;default:h=c.NONE}break;case 2:switch(e.touches.TWO){case ce.DOLLY_PAN:if(e.enableZoom===!1&&e.enablePan===!1)return;w(),h=c.TOUCH_DOLLY_PAN;break;case ce.DOLLY_ROTATE:if(e.enableZoom===!1&&e.enableRotate===!1)return;b(),h=c.TOUCH_DOLLY_ROTATE;break;default:h=c.NONE}break;default:h=c.NONE}h!==c.NONE&&e.dispatchEvent(E)}function Le(t){switch(_e(t),h){case c.TOUCH_ROTATE:if(e.enableRotate===!1)return;H(t),e.update();break;case c.TOUCH_PAN:if(e.enablePan===!1)return;R(t),e.update();break;case c.TOUCH_DOLLY_PAN:if(e.enableZoom===!1&&e.enablePan===!1)return;ie(t),e.update();break;case c.TOUCH_DOLLY_ROTATE:if(e.enableZoom===!1&&e.enableRotate===!1)return;we(t),e.update();break;default:h=c.NONE}}function F(t){e.enabled!==!1&&t.preventDefault()}function Ue(t){d.push(t)}function Ce(t){delete y[t.pointerId];for(let n=0;n<d.length;n++)if(d[n].pointerId==t.pointerId){d.splice(n,1);return}}function _e(t){let n=y[t.pointerId];n===void 0&&(n=new W,y[t.pointerId]=n),n.set(t.pageX,t.pageY)}function Se(t){const n=t.pointerId===d[0].pointerId?d[1]:d[0];return y[n.pointerId]}i!==void 0&&this.connect(i),this.update()}};const dt=f.forwardRef(({makeDefault:o,camera:a,regress:i,domElement:e,enableDamping:P=!0,keyEvents:E=!1,onChange:x,onStart:c,onEnd:h,...te},u)=>{const m=K(l=>l.invalidate),Z=K(l=>l.camera),_=K(l=>l.gl),B=K(l=>l.events),I=K(l=>l.setEvents),j=K(l=>l.set),D=K(l=>l.get),L=K(l=>l.performance),S=a||Z,A=e||B.connected||_.domElement,g=f.useMemo(()=>new ct(S),[S]);return Fe(()=>{g.enabled&&g.update()},-1),f.useEffect(()=>(E&&g.connect(E===!0?A:E),g.connect(A),()=>void g.dispose()),[E,A,i,g,m]),f.useEffect(()=>{const l=y=>{m(),i&&L.regress(),x&&x(y)},C=y=>{c&&c(y)},d=y=>{h&&h(y)};return g.addEventListener("change",l),g.addEventListener("start",C),g.addEventListener("end",d),()=>{g.removeEventListener("start",C),g.removeEventListener("end",d),g.removeEventListener("change",l)}},[x,c,h,g,m,I]),f.useEffect(()=>{if(o){const l=D().controls;return j({controls:g}),()=>j({controls:l})}},[o,g]),f.createElement("primitive",We({ref:u,object:g,enableDamping:P},te))}),ht=()=>{const{progress:o}=it();return Re.jsxs(at,{children:[Re.jsx("span",{className:"canvas-load"}),Re.jsxs("p",{style:{fontSize:18,color:"#f1f1f1",fontWeight:800,marginTop:40},children:[o.toFixed(2),"%"]})]})};export{ht as L,dt as O};
